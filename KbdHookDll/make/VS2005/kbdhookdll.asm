; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	d:\Project\C++Projects\Release\DRMComp\KbdHookDll\src\kbdhookdll.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?UnInitKbdHook@@YGHXZ				; UnInitKbdHook
PUBLIC	?StopLog@@YGHXZ					; StopLog
PUBLIC	_DllMain@12
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
_BSS	SEGMENT
_ServerStatus DD 01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
; File d:\project\c++projects\release\drmcomp\kbdhookdll\src\kbdhookdll.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _DllMain@12
_TEXT	SEGMENT
_hDll$ = 8						; size = 4
_fdwReason$ = 12					; size = 4
___formal$ = 16						; size = 4
_DllMain@12 PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 59   : 	if( fdwReason == DLL_PROCESS_DETACH )

	cmp	DWORD PTR _fdwReason$[ebp], 0
	jne	SHORT $LN3@DllMain

; 60   : 	{
; 61   : 		if( ServerStatus == LogInProgress )

	cmp	DWORD PTR _ServerStatus, 2
	jne	SHORT $LN2@DllMain

; 62   : 		{
; 63   : 			StopLog(  );

	call	?StopLog@@YGHXZ				; StopLog
$LN2@DllMain:

; 64   : 		}
; 65   : 
; 66   : 		if( ServerStatus == Initialize )

	cmp	DWORD PTR _ServerStatus, 1
	jne	SHORT $LN3@DllMain

; 67   : 		{
; 68   : 			UnInitKbdHook(  );

	call	?UnInitKbdHook@@YGHXZ			; UnInitKbdHook
$LN3@DllMain:

; 69   : 		}
; 70   : 	}
; 71   : 
; 72   : 	return TRUE;

	mov	eax, 1

; 73   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
PUBLIC	?SetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z	; SetServerStatus
PUBLIC	?ThreadForLogInFile@@YGKPAX@Z			; ThreadForLogInFile
PUBLIC	??_C@_1CA@GAHFOLKP@?$AA?2?$AA?2?$AA?4?$AA?2?$AAD?$AAr?$AAm?$AAK?$AAb?$AAd?$AAH?$AAo?$AAo?$AAk?$AA0?$AA?$AA@ ; `string'
PUBLIC	?StringCbCopyW@@YGJPA_WIPB_W@Z			; StringCbCopyW
PUBLIC	_RtlSecureZeroMemory
PUBLIC	?StringCbLengthW@@YGJPB_WIPAI@Z			; StringCbLengthW
PUBLIC	??_C@_1EG@PAFGOIEE@?$AA?2?$AAB?$AAa?$AAs?$AAe?$AAN?$AAa?$AAm?$AAe?$AAd?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAU?$AAE?$AAv?$AAe?$AAn?$AAt?$AAF?$AAo?$AAr?$AAK?$AAb?$AAd?$AAH?$AAo@ ; `string'
PUBLIC	??_C@_1O@KLFMMJAJ@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IK@FHIPECMD@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?2?$AAc?$AA?$CL?$AA?$CL?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAr?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?2?$AAd@ ; `string'
PUBLIC	?__LINE__Var@?1??InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z@4JA ; `InitKbdHook'::`2'::__LINE__Var
PUBLIC	?ConvertEventName@@YAHPA_WPAPA_W@Z		; ConvertEventName
PUBLIC	??_C@_1EG@PBIOJIKC@?$AA?2?$AAB?$AAa?$AAs?$AAe?$AAN?$AAa?$AAm?$AAe?$AAd?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAK?$AAE?$AAv?$AAe?$AAn?$AAt?$AAF?$AAo?$AAr?$AAK?$AAb?$AAd?$AAH?$AAo@ ; `string'
PUBLIC	?InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z		; InitKbdHook
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	_free:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp__CreateEventW@16:PROC
EXTRN	__wassert:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__except_handler4:PROC
EXTRN	__RTC_UninitUse:PROC
_BSS	SEGMENT
_LogMode DD	01H DUP (?)
_hThread DD	01H DUP (?)
_hKbdHookDev DD	01H DUP (?)
_hLogFile DD	01H DUP (?)
_pwszLogFileName DD 01H DUP (?)
_pKey	DD	01H DUP (?)
_hEventThreadExit DD 01H DUP (?)
_hEventU DD	01H DUP (?)
_hEventK DD	01H DUP (?)
_pwszEventUName DD 01H DUP (?)
_pwszEventKName DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_1CA@GAHFOLKP@?$AA?2?$AA?2?$AA?4?$AA?2?$AAD?$AAr?$AAm?$AAK?$AAb?$AAd?$AAH?$AAo?$AAo?$AAk?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@GAHFOLKP@?$AA?2?$AA?2?$AA?4?$AA?2?$AAD?$AAr?$AAm?$AAK?$AAb?$AAd?$AAH?$AAo?$AAo?$AAk?$AA0?$AA?$AA@ DB '\'
	DB	00H, '\', 00H, '.', 00H, '\', 00H, 'D', 00H, 'r', 00H, 'm', 00H
	DB	'K', 00H, 'b', 00H, 'd', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k'
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@PAFGOIEE@?$AA?2?$AAB?$AAa?$AAs?$AAe?$AAN?$AAa?$AAm?$AAe?$AAd?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAU?$AAE?$AAv?$AAe?$AAn?$AAt?$AAF?$AAo?$AAr?$AAK?$AAb?$AAd?$AAH?$AAo@
CONST	SEGMENT
??_C@_1EG@PAFGOIEE@?$AA?2?$AAB?$AAa?$AAs?$AAe?$AAN?$AAa?$AAm?$AAe?$AAd?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAU?$AAE?$AAv?$AAe?$AAn?$AAt?$AAF?$AAo?$AAr?$AAK?$AAb?$AAd?$AAH?$AAo@ DB '\'
	DB	00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'N', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, 'd', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'U', 00H, 'E', 00H
	DB	'v', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'K', 00H, 'b', 00H, 'd', 00H, 'H', 00H, 'o', 00H, 'o', 00H
	DB	'k', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KLFMMJAJ@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KLFMMJAJ@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@ DB 's', 00H, 't'
	DB	00H, 'a', 00H, 't', 00H, 'u', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IK@FHIPECMD@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?2?$AAc?$AA?$CL?$AA?$CL?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAr?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?2?$AAd@
CONST	SEGMENT
??_C@_1IK@FHIPECMD@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?2?$AAc?$AA?$CL?$AA?$CL?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAr?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?2?$AAd@ DB 'd'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'j', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, '\', 00H, 'c', 00H, '+', 00H, '+'
	DB	00H, 'p', 00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 's', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'l', 00H, 'e'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, '\', 00H, 'd', 00H, 'r', 00H
	DB	'm', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, '\', 00H, 'k'
	DB	00H, 'b', 00H, 'd', 00H, 'h', 00H, 'o', 00H, 'o', 00H, 'k', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'k', 00H, 'b', 00H, 'd', 00H, 'h', 00H, 'o', 00H
	DB	'o', 00H, 'k', 00H, 'd', 00H, 'l', 00H, 'l', 00H, '.', 00H, 'c'
	DB	00H, 'p', 00H, 'p', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z@4JA DD 04cH ; `InitKbdHook'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EG@PBIOJIKC@?$AA?2?$AAB?$AAa?$AAs?$AAe?$AAN?$AAa?$AAm?$AAe?$AAd?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAK?$AAE?$AAv?$AAe?$AAn?$AAt?$AAF?$AAo?$AAr?$AAK?$AAb?$AAd?$AAH?$AAo@
CONST	SEGMENT
??_C@_1EG@PBIOJIKC@?$AA?2?$AAB?$AAa?$AAs?$AAe?$AAN?$AAa?$AAm?$AAe?$AAd?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAK?$AAE?$AAv?$AAe?$AAn?$AAt?$AAF?$AAo?$AAr?$AAK?$AAb?$AAd?$AAH?$AAo@ DB '\'
	DB	00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'N', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, 'd', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'K', 00H, 'E', 00H
	DB	'v', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'K', 00H, 'b', 00H, 'd', 00H, 'H', 00H, 'o', 00H, 'o', 00H
	DB	'k', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z DD 0fffffffeH
	DD	00H
	DD	0fffffeb0H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN19@InitKbdHoo
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z
_TEXT	SEGMENT
tv184 = -320						; size = 4
$T62639 = -309						; size = 1
_b$62427 = -108						; size = 4
_FailedCode$ = -96					; size = 4
_LastError$ = -84					; size = 4
_cbRet$ = -72						; size = 4
_InitKbdHookStruct$ = -60				; size = 8
_cbName$ = -44						; size = 4
_status$ = -32						; size = 4
__$SEHRec$ = -24					; size = 24
_pwszFileName$ = 8					; size = 4
_LogMode$ = 12						; size = 4
?InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z PROC		; InitKbdHook, COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -304				; fffffed0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-320]
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	BYTE PTR $T62639[ebp], 0

; 77   : 	BOOL status;
; 78   : 	DWORD cbName;
; 79   : 	FOR_INIT_KBD_HOOK InitKbdHookStruct;
; 80   : 	ULONG cbRet;
; 81   : 	DWORD LastError = ERROR_SUCCESS;

	mov	DWORD PTR _LastError$[ebp], 0

; 82   : 	
; 83   : 	enum CodeFailed { 
; 84   : 		Success = 1,
; 85   : 		AllocMemForSharedBuf,
; 86   : 		AllocMemForLogFileName,
; 87   : 		CreateLogFile,
; 88   : 		OpenKbdHookDev,
; 89   : 		InternalError
; 90   : 	} FailedCode = Success;

	mov	DWORD PTR _FailedCode$[ebp], 1

; 91   : 
; 92   : 	__try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 93   : 	{
; 94   : 		status = ConvertEventName( KERNEL_EVENT_NAME, &pwszEventKName );

	push	OFFSET _pwszEventKName
	push	OFFSET ??_C@_1EG@PBIOJIKC@?$AA?2?$AAB?$AAa?$AAs?$AAe?$AAN?$AAa?$AAm?$AAe?$AAd?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAK?$AAE?$AAv?$AAe?$AAn?$AAt?$AAF?$AAo?$AAr?$AAK?$AAb?$AAd?$AAH?$AAo@
	call	?ConvertEventName@@YAHPA_WPAPA_W@Z	; ConvertEventName
	add	esp, 8
	mov	BYTE PTR $T62639[ebp], 1
	mov	DWORD PTR _status$[ebp], eax

; 95   : 		assert( status );

	cmp	BYTE PTR $T62639[ebp], 0
	jne	SHORT $LN23@InitKbdHoo
	push	OFFSET $LN24@InitKbdHoo
	call	__RTC_UninitUse
	add	esp, 4
$LN23@InitKbdHoo:
	cmp	DWORD PTR _status$[ebp], 0
	jne	SHORT $LN16@InitKbdHoo
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_1IK@FHIPECMD@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?2?$AAc?$AA?$CL?$AA?$CL?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAr?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?2?$AAd@
	push	OFFSET ??_C@_1O@KLFMMJAJ@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN16@InitKbdHoo:

; 96   : 		
; 97   : 		status = ConvertEventName( USER_EVENT_NAME, &pwszEventUName );

	push	OFFSET _pwszEventUName
	push	OFFSET ??_C@_1EG@PAFGOIEE@?$AA?2?$AAB?$AAa?$AAs?$AAe?$AAN?$AAa?$AAm?$AAe?$AAd?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAU?$AAE?$AAv?$AAe?$AAn?$AAt?$AAF?$AAo?$AAr?$AAK?$AAb?$AAd?$AAH?$AAo@
	call	?ConvertEventName@@YAHPA_WPAPA_W@Z	; ConvertEventName
	add	esp, 8
	mov	BYTE PTR $T62639[ebp], 1
	mov	DWORD PTR _status$[ebp], eax

; 98   : 		assert( status );

	cmp	BYTE PTR $T62639[ebp], 0
	jne	SHORT $LN25@InitKbdHoo
	push	OFFSET $LN24@InitKbdHoo
	call	__RTC_UninitUse
	add	esp, 4
$LN25@InitKbdHoo:
	cmp	DWORD PTR _status$[ebp], 0
	jne	SHORT $LN17@InitKbdHoo
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z@4JA
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_1IK@FHIPECMD@?$AAd?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?2?$AAc?$AA?$CL?$AA?$CL?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAr?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?2?$AAd@
	push	OFFSET ??_C@_1O@KLFMMJAJ@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN17@InitKbdHoo:

; 99   : 		
; 100  : 		hEventK = CreateEvent( NULL, FALSE, FALSE, pwszEventKName );

	mov	esi, esp
	mov	eax, DWORD PTR _pwszEventKName
	push	eax
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hEventK, eax

; 101  : 		hEventU = CreateEvent( NULL, FALSE, TRUE, pwszEventUName );

	mov	esi, esp
	mov	eax, DWORD PTR _pwszEventUName
	push	eax
	push	1
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hEventU, eax

; 102  : 		hEventThreadExit = CreateEvent( NULL, FALSE, FALSE, NULL );

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hEventThreadExit, eax

; 103  : 
; 104  : 		pKey = (PKEY)VirtualAlloc( NULL, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );

	mov	esi, esp
	push	4
	push	12288					; 00003000H
	push	4096					; 00001000H
	push	0
	call	DWORD PTR __imp__VirtualAlloc@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pKey, eax

; 105  : 
; 106  : 		if( !pKey )

	cmp	DWORD PTR _pKey, 0
	jne	SHORT $LN12@InitKbdHoo

; 107  : 		{
; 108  : 			LastError = ERROR_NOT_ENOUGH_MEMORY;

	mov	DWORD PTR _LastError$[ebp], 8

; 109  : 			status = 0;

	mov	BYTE PTR $T62639[ebp], 1
	mov	DWORD PTR _status$[ebp], 0

; 110  : 			FailedCode = AllocMemForSharedBuf;

	mov	DWORD PTR _FailedCode$[ebp], 2

; 111  : 			__leave;

	jmp	$LN13@InitKbdHoo
$LN12@InitKbdHoo:

; 112  : 		}
; 113  : 
; 114  : 		StringCbLength( pwszFileName, 255 * sizeof( WCHAR ), (size_t*)&cbName );

	lea	eax, DWORD PTR _cbName$[ebp]
	push	eax
	push	510					; 000001feH
	mov	ecx, DWORD PTR _pwszFileName$[ebp]
	push	ecx
	call	?StringCbLengthW@@YGJPB_WIPAI@Z		; StringCbLengthW

; 115  : 
; 116  : 		pwszLogFileName = (PWCHAR)malloc( cbName + sizeof( WCHAR ) );

	mov	eax, DWORD PTR _cbName$[ebp]
	add	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pwszLogFileName, eax

; 117  : 		
; 118  : 		if( !pwszLogFileName )

	cmp	DWORD PTR _pwszLogFileName, 0
	jne	SHORT $LN11@InitKbdHoo

; 119  : 		{
; 120  : 			LastError = ERROR_NOT_ENOUGH_MEMORY;

	mov	DWORD PTR _LastError$[ebp], 8

; 121  : 			status = 0;

	mov	BYTE PTR $T62639[ebp], 1
	mov	DWORD PTR _status$[ebp], 0

; 122  : 			FailedCode = AllocMemForLogFileName;

	mov	DWORD PTR _FailedCode$[ebp], 3

; 123  : 			__leave;

	jmp	$LN13@InitKbdHoo
$LN11@InitKbdHoo:

; 124  : 		}
; 125  : 
; 126  : 		SecureZeroMemory( pwszLogFileName, cbName + sizeof( WCHAR ) );

	mov	eax, DWORD PTR _cbName$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pwszLogFileName
	push	ecx
	call	_RtlSecureZeroMemory
	add	esp, 8

; 127  : 
; 128  : 		StringCbCopy( pwszLogFileName, cbName + sizeof( WCHAR ), pwszFileName );

	mov	eax, DWORD PTR _pwszFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cbName$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _pwszLogFileName
	push	edx
	call	?StringCbCopyW@@YGJPA_WIPB_W@Z		; StringCbCopyW

; 129  : 
; 130  : 		hLogFile = CreateFile( pwszLogFileName, GENERIC_ALL, FILE_SHARE_READ,
; 131  : 			NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

	mov	esi, esp
	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	1
	push	268435456				; 10000000H
	mov	eax, DWORD PTR _pwszLogFileName
	push	eax
	call	DWORD PTR __imp__CreateFileW@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hLogFile, eax

; 132  : 
; 133  : 		if( hLogFile == INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hLogFile, -1
	jne	SHORT $LN10@InitKbdHoo

; 134  : 		{
; 135  : 			LastError = ERROR_TOO_MANY_OPEN_FILES;

	mov	DWORD PTR _LastError$[ebp], 4

; 136  : 			status = 0;

	mov	BYTE PTR $T62639[ebp], 1
	mov	DWORD PTR _status$[ebp], 0

; 137  : 			FailedCode = CreateLogFile;

	mov	DWORD PTR _FailedCode$[ebp], 4

; 138  : 			__leave;

	jmp	$LN13@InitKbdHoo
$LN10@InitKbdHoo:

; 139  : 		}
; 140  : 
; 141  : 		hKbdHookDev = CreateFile( L"\\\\.\\DrmKbdHook0", GENERIC_READ | GENERIC_WRITE,
; 142  : 			0, NULL, OPEN_EXISTING, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	push	3
	push	0
	push	0
	push	-1073741824				; c0000000H
	push	OFFSET ??_C@_1CA@GAHFOLKP@?$AA?2?$AA?2?$AA?4?$AA?2?$AAD?$AAr?$AAm?$AAK?$AAb?$AAd?$AAH?$AAo?$AAo?$AAk?$AA0?$AA?$AA@
	call	DWORD PTR __imp__CreateFileW@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hKbdHookDev, eax

; 143  : 
; 144  : 		if( hKbdHookDev == INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hKbdHookDev, -1
	jne	SHORT $LN9@InitKbdHoo

; 145  : 		{
; 146  : 			LastError = ERROR_TOO_MANY_OPEN_FILES;

	mov	DWORD PTR _LastError$[ebp], 4

; 147  : 			status = 0;

	mov	BYTE PTR $T62639[ebp], 1
	mov	DWORD PTR _status$[ebp], 0

; 148  : 			FailedCode = OpenKbdHookDev;

	mov	DWORD PTR _FailedCode$[ebp], 5

; 149  : 			__leave;

	jmp	$LN13@InitKbdHoo
$LN9@InitKbdHoo:

; 150  : 		}
; 151  : 
; 152  : 		InitKbdHookStruct.Size = 4096;

	mov	DWORD PTR _InitKbdHookStruct$[ebp+4], 4096 ; 00001000H

; 153  : 		InitKbdHookStruct.StartVA = (PVOID)pKey;

	mov	eax, DWORD PTR _pKey
	mov	DWORD PTR _InitKbdHookStruct$[ebp], eax

; 154  : 
; 155  : 		BOOL b = DeviceIoControl( hKbdHookDev, IOCTL_KBD_HOOK_INIT, &InitKbdHookStruct,
; 156  : 			sizeof( FOR_INIT_KBD_HOOK ), NULL, 0, &cbRet, NULL ) ;

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _cbRet$[ebp]
	push	eax
	push	0
	push	0
	push	8
	lea	ecx, DWORD PTR _InitKbdHookStruct$[ebp]
	push	ecx
	push	2287204					; 0022e664H
	mov	edx, DWORD PTR _hKbdHookDev
	push	edx
	call	DWORD PTR __imp__DeviceIoControl@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _b$62427[ebp], eax

; 157  : 		
; 158  : 		if( !b )

	cmp	DWORD PTR _b$62427[ebp], 0
	jne	SHORT $LN8@InitKbdHoo

; 159  : 		{
; 160  : 			LastError = ERROR_INTERNAL_ERROR;

	mov	DWORD PTR _LastError$[ebp], 1359	; 0000054fH

; 161  : 			status = 0;

	mov	BYTE PTR $T62639[ebp], 1
	mov	DWORD PTR _status$[ebp], 0

; 162  : 			FailedCode = InternalError;

	mov	DWORD PTR _FailedCode$[ebp], 6

; 163  : 			__leave;

	jmp	SHORT $LN13@InitKbdHoo
$LN8@InitKbdHoo:

; 164  : 		}
; 165  : 
; 166  : 		hThread = CreateThread( NULL, //security attrib 
; 167  : 			0, // default stack size
; 168  : 			ThreadForLogInFile,
; 169  : 			NULL,
; 170  : 			NULL, // no flags
; 171  : 			NULL // thread id not return 
; 172  : 		);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	OFFSET ?ThreadForLogInFile@@YGKPAX@Z	; ThreadForLogInFile
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hThread, eax

; 173  : 
; 174  : 		::LogMode = LogMode;

	mov	eax, DWORD PTR _LogMode$[ebp]
	mov	DWORD PTR _LogMode, eax

; 175  : 
; 176  : 		SetServerStatus( Initialize );

	push	1
	call	?SetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z ; SetServerStatus
	add	esp, 4
$LN13@InitKbdHoo:

; 177  : 	}
; 178  : 	__finally

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	call	$LN21@InitKbdHoo
	jmp	$LN22@InitKbdHoo
$LN19@InitKbdHoo:
$LN36@InitKbdHoo:
$LN21@InitKbdHoo:

; 179  : 	{
; 180  : 		switch( FailedCode )

	mov	eax, DWORD PTR _FailedCode$[ebp]
	mov	DWORD PTR tv184[ebp], eax
	mov	ecx, DWORD PTR tv184[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv184[ebp], ecx
	cmp	DWORD PTR tv184[ebp], 4
	ja	$LN20@InitKbdHoo
	mov	edx, DWORD PTR tv184[ebp]
	jmp	DWORD PTR $LN35@InitKbdHoo[edx*4]
$LN5@InitKbdHoo:

; 181  : 		{
; 182  : 			case InternalError:
; 183  : 			case OpenKbdHookDev:
; 184  : 				CloseHandle( hLogFile );

	mov	esi, esp
	mov	eax, DWORD PTR _hLogFile
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@InitKbdHoo:

; 185  : 			case CreateLogFile:
; 186  : 				free( pwszLogFileName );

	mov	eax, DWORD PTR _pwszLogFileName
	push	eax
	call	_free
	add	esp, 4
$LN3@InitKbdHoo:

; 187  : 			case AllocMemForLogFileName:
; 188  : 				VirtualFree( pKey, 4096, MEM_RELEASE );

	mov	esi, esp
	push	32768					; 00008000H
	push	4096					; 00001000H
	mov	eax, DWORD PTR _pKey
	push	eax
	call	DWORD PTR __imp__VirtualFree@12
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@InitKbdHoo:

; 189  : 			case AllocMemForSharedBuf:
; 190  : 				free( pwszEventUName );

	mov	eax, DWORD PTR _pwszEventUName
	push	eax
	call	_free
	add	esp, 4

; 191  : 				free( pwszEventKName );

	mov	eax, DWORD PTR _pwszEventKName
	push	eax
	call	_free
	add	esp, 4

; 192  : 				CloseHandle( hEventK );

	mov	esi, esp
	mov	eax, DWORD PTR _hEventK
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 193  : 				CloseHandle( hEventU );

	mov	esi, esp
	mov	eax, DWORD PTR _hEventU
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@InitKbdHoo:
$LN34@InitKbdHoo:
	ret	0
$LN22@InitKbdHoo:

; 194  : 			break;
; 195  : 			default:
; 196  : 			break;
; 197  : 		}
; 198  : 	}
; 199  : 
; 200  : 	SetLastError( LastError );

	mov	esi, esp
	mov	eax, DWORD PTR _LastError$[ebp]
	push	eax
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 201  : 	return status;

	cmp	BYTE PTR $T62639[ebp], 0
	jne	SHORT $LN26@InitKbdHoo
	push	OFFSET $LN24@InitKbdHoo
	call	__RTC_UninitUse
	add	esp, 4
$LN26@InitKbdHoo:
	mov	eax, DWORD PTR _status$[ebp]

; 202  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN33@InitKbdHoo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 320				; 00000140H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN33@InitKbdHoo:
	DD	6
	DD	$LN32@InitKbdHoo
$LN32@InitKbdHoo:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN24@InitKbdHoo
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN27@InitKbdHoo
	DD	-60					; ffffffc4H
	DD	8
	DD	$LN28@InitKbdHoo
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN29@InitKbdHoo
	DD	-84					; ffffffacH
	DD	4
	DD	$LN30@InitKbdHoo
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN31@InitKbdHoo
$LN31@InitKbdHoo:
	DB	70					; 00000046H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN30@InitKbdHoo:
	DB	76					; 0000004cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN29@InitKbdHoo:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN28@InitKbdHoo:
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	75					; 0000004bH
	DB	98					; 00000062H
	DB	100					; 00000064H
	DB	72					; 00000048H
	DB	111					; 0000006fH
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$LN27@InitKbdHoo:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN24@InitKbdHoo:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
	npad	1
$LN35@InitKbdHoo:
	DD	$LN2@InitKbdHoo
	DD	$LN3@InitKbdHoo
	DD	$LN4@InitKbdHoo
	DD	$LN5@InitKbdHoo
	DD	$LN5@InitKbdHoo
?InitKbdHook@@YGHPB_WW4_LOG_MODE@@@Z ENDP		; InitKbdHook
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files\microsoft visual studio 8\vc\platformsdk\include\winnt.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_vptr$ = -8						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 8401 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 8402 :     volatile char *vptr = (volatile char *)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8403 : 
; 8404 : #if defined(_M_AMD64)
; 8405 : 
; 8406 :         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 8407 : 
; 8408 : #else
; 8409 : 
; 8410 :     while (cnt) {

	cmp	DWORD PTR _cnt$[ebp], 0
	je	SHORT $LN1@RtlSecureZ

; 8411 :         *vptr = 0;

	mov	eax, DWORD PTR _vptr$[ebp]
	mov	BYTE PTR [eax], 0

; 8412 :         vptr++;

	mov	eax, DWORD PTR _vptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _vptr$[ebp], eax

; 8413 :         cnt--;

	mov	eax, DWORD PTR _cnt$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cnt$[ebp], eax

; 8414 :     }

	jmp	SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8415 : 
; 8416 : #endif
; 8417 : 
; 8418 :     return ptr;

	mov	eax, DWORD PTR _ptr$[ebp]

; 8419 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	?StringCopyWorkerW@@YGJPA_WIPB_W@Z		; StringCopyWorkerW
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files\microsoft visual studio 8\vc\platformsdk\include\strsafe.h
;	COMDAT ?StringCbCopyW@@YGJPA_WIPB_W@Z
_TEXT	SEGMENT
_cchDest$ = -20						; size = 4
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cbDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCbCopyW@@YGJPA_WIPB_W@Z PROC			; StringCbCopyW, COMDAT

; 606  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 607  :     HRESULT hr;
; 608  :     size_t cchDest;
; 609  : 
; 610  :     // convert to count of characters
; 611  :     cchDest = cbDest / sizeof(wchar_t);

	mov	eax, DWORD PTR _cbDest$[ebp]
	shr	eax, 1
	mov	DWORD PTR _cchDest$[ebp], eax

; 612  : 
; 613  :     if (cchDest > STRSAFE_MAX_CCH)

	cmp	DWORD PTR _cchDest$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN2@StringCbCo

; 614  :     {
; 615  :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 616  :     }
; 617  :     else

	jmp	SHORT $LN1@StringCbCo
$LN2@StringCbCo:

; 618  :     {
; 619  :         hr = StringCopyWorkerW(pszDest, cchDest, pszSrc);

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	?StringCopyWorkerW@@YGJPA_WIPB_W@Z	; StringCopyWorkerW
	mov	DWORD PTR _hr$[ebp], eax
$LN1@StringCbCo:

; 620  :     }
; 621  : 
; 622  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 623  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringCbCopyW@@YGJPA_WIPB_W@Z ENDP			; StringCbCopyW
_TEXT	ENDS
PUBLIC	?StringLengthWorkerW@@YGJPB_WIPAI@Z		; StringLengthWorkerW
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?StringCbLengthW@@YGJPB_WIPAI@Z
_TEXT	SEGMENT
_cchLength$ = -32					; size = 4
_cchMax$ = -20						; size = 4
_hr$ = -8						; size = 4
_psz$ = 8						; size = 4
_cbMax$ = 12						; size = 4
_pcbLength$ = 16					; size = 4
?StringCbLengthW@@YGJPB_WIPAI@Z PROC			; StringCbLengthW, COMDAT

; 5189 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5190 :     HRESULT hr;
; 5191 :     size_t cchMax;
; 5192 :     size_t cchLength = 0;

	mov	DWORD PTR _cchLength$[ebp], 0

; 5193 : 
; 5194 :     // convert to count of characters
; 5195 :     cchMax = cbMax / sizeof(wchar_t);

	mov	eax, DWORD PTR _cbMax$[ebp]
	shr	eax, 1
	mov	DWORD PTR _cchMax$[ebp], eax

; 5196 : 
; 5197 :     if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))

	cmp	DWORD PTR _psz$[ebp], 0
	je	SHORT $LN5@StringCbLe
	cmp	DWORD PTR _cchMax$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN6@StringCbLe
$LN5@StringCbLe:

; 5198 :     {
; 5199 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 5200 :     }
; 5201 :     else

	jmp	SHORT $LN4@StringCbLe
$LN6@StringCbLe:

; 5202 :     {
; 5203 :         hr = StringLengthWorkerW(psz, cchMax, &cchLength);

	lea	eax, DWORD PTR _cchLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchMax$[ebp]
	push	ecx
	mov	edx, DWORD PTR _psz$[ebp]
	push	edx
	call	?StringLengthWorkerW@@YGJPB_WIPAI@Z	; StringLengthWorkerW
	mov	DWORD PTR _hr$[ebp], eax
$LN4@StringCbLe:

; 5204 :     }
; 5205 : 
; 5206 :     if (pcbLength)

	cmp	DWORD PTR _pcbLength$[ebp], 0
	je	SHORT $LN3@StringCbLe

; 5207 :     {
; 5208 :         if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@StringCbLe

; 5209 :         {
; 5210 :             // safe to multiply cch * sizeof(wchar_t) since cch < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
; 5211 :             *pcbLength = cchLength * sizeof(wchar_t);

	mov	eax, DWORD PTR _cchLength$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _pcbLength$[ebp]
	mov	DWORD PTR [ecx], eax

; 5212 :         }
; 5213 :         else

	jmp	SHORT $LN3@StringCbLe
$LN2@StringCbLe:

; 5214 :         {
; 5215 :             *pcbLength = 0;

	mov	eax, DWORD PTR _pcbLength$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@StringCbLe:

; 5216 :         }
; 5217 :     }
; 5218 : 
; 5219 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 5220 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@StringCbLe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN11@StringCbLe:
	DD	1
	DD	$LN10@StringCbLe
$LN10@StringCbLe:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN9@StringCbLe
$LN9@StringCbLe:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?StringCbLengthW@@YGJPB_WIPAI@Z ENDP			; StringCbLengthW
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?StringCopyWorkerW@@YGJPA_WIPB_W@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCopyWorkerW@@YGJPA_WIPB_W@Z PROC			; StringCopyWorkerW, COMDAT

; 5267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5268 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 5269 : 
; 5270 :     if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN3@StringCopy

; 5271 :     {
; 5272 :         // can not null terminate a zero-byte dest buffer
; 5273 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 5274 :     }
; 5275 :     else

	jmp	SHORT $LN4@StringCopy
$LN3@StringCopy:

; 5276 :     {
; 5277 :         while (cchDest && (*pszSrc != L'\0'))

	cmp	DWORD PTR _cchDest$[ebp], 0
	je	SHORT $LN2@StringCopy
	mov	eax, DWORD PTR _pszSrc$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@StringCopy

; 5278 :         {
; 5279 :             *pszDest++ = *pszSrc++;

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _pszDest$[ebp]
	add	eax, 2
	mov	DWORD PTR _pszDest$[ebp], eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pszSrc$[ebp], ecx

; 5280 :             cchDest--;

	mov	eax, DWORD PTR _cchDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchDest$[ebp], eax

; 5281 :         }

	jmp	SHORT $LN3@StringCopy
$LN2@StringCopy:

; 5282 : 
; 5283 :         if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN1@StringCopy

; 5284 :         {
; 5285 :             // we are going to truncate pszDest
; 5286 :             pszDest--;

	mov	eax, DWORD PTR _pszDest$[ebp]
	sub	eax, 2
	mov	DWORD PTR _pszDest$[ebp], eax

; 5287 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	DWORD PTR _hr$[ebp], -2147024774	; 8007007aH
$LN1@StringCopy:

; 5288 :         }
; 5289 : 
; 5290 :         *pszDest= L'\0';

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	WORD PTR [eax], 0
$LN4@StringCopy:

; 5291 :     }
; 5292 : 
; 5293 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 5294 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringCopyWorkerW@@YGJPA_WIPB_W@Z ENDP			; StringCopyWorkerW
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?StringLengthWorkerW@@YGJPB_WIPAI@Z
_TEXT	SEGMENT
_cchMaxPrev$ = -20					; size = 4
_hr$ = -8						; size = 4
_psz$ = 8						; size = 4
_cchMax$ = 12						; size = 4
_pcchLength$ = 16					; size = 4
?StringLengthWorkerW@@YGJPB_WIPAI@Z PROC		; StringLengthWorkerW, COMDAT

; 7149 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7150 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 7151 :     size_t cchMaxPrev = cchMax;

	mov	eax, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _cchMaxPrev$[ebp], eax
$LN6@StringLeng:

; 7152 : 
; 7153 :     while (cchMax && (*psz != L'\0'))

	cmp	DWORD PTR _cchMax$[ebp], 0
	je	SHORT $LN5@StringLeng
	mov	eax, DWORD PTR _psz$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@StringLeng

; 7154 :     {
; 7155 :         psz++;

	mov	eax, DWORD PTR _psz$[ebp]
	add	eax, 2
	mov	DWORD PTR _psz$[ebp], eax

; 7156 :         cchMax--;

	mov	eax, DWORD PTR _cchMax$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchMax$[ebp], eax

; 7157 :     }

	jmp	SHORT $LN6@StringLeng
$LN5@StringLeng:

; 7158 : 
; 7159 :     if (cchMax == 0)

	cmp	DWORD PTR _cchMax$[ebp], 0
	jne	SHORT $LN4@StringLeng

; 7160 :     {
; 7161 :         // the string is longer than cchMax
; 7162 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H
$LN4@StringLeng:

; 7163 :     }
; 7164 : 
; 7165 :     if (pcchLength)

	cmp	DWORD PTR _pcchLength$[ebp], 0
	je	SHORT $LN3@StringLeng

; 7166 :     {
; 7167 :         if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@StringLeng

; 7168 :         {
; 7169 :             *pcchLength = cchMaxPrev - cchMax;

	mov	eax, DWORD PTR _cchMaxPrev$[ebp]
	sub	eax, DWORD PTR _cchMax$[ebp]
	mov	ecx, DWORD PTR _pcchLength$[ebp]
	mov	DWORD PTR [ecx], eax

; 7170 :         }
; 7171 :         else

	jmp	SHORT $LN3@StringLeng
$LN2@StringLeng:

; 7172 :         {
; 7173 :             *pcchLength = 0;

	mov	eax, DWORD PTR _pcchLength$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@StringLeng:

; 7174 :         }
; 7175 :     }
; 7176 : 
; 7177 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 7178 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringLengthWorkerW@@YGJPB_WIPAI@Z ENDP		; StringLengthWorkerW
_TEXT	ENDS
PUBLIC	??_C@_1BA@LJDFMAL@?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AA?2?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1BA@LJDFMAL@?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AA?2?$AA?$AA@
; File d:\project\c++projects\release\drmcomp\kbdhookdll\src\kbdhookdll.cpp
CONST	SEGMENT
??_C@_1BA@LJDFMAL@?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AA?2?$AA?$AA@ DB 'G', 00H
	DB	'l', 00H, 'o', 00H, 'b', 00H, 'a', 00H, 'l', 00H, '\', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?ConvertEventName@@YAHPA_WPAPA_W@Z
_TEXT	SEGMENT
_cbDDKName$ = -8					; size = 4
_pwszEventDDKName$ = 8					; size = 4
_pwszEventSDKName$ = 12					; size = 4
?ConvertEventName@@YAHPA_WPAPA_W@Z PROC			; ConvertEventName, COMDAT

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 206  : 	DWORD cbDDKName;
; 207  : 	
; 208  : 	StringCbLength( pwszEventDDKName, sizeof( WCHAR ) * ( 100 + 1 ),
; 209  : 		 (size_t*)&cbDDKName );

	lea	eax, DWORD PTR _cbDDKName$[ebp]
	push	eax
	push	202					; 000000caH
	mov	ecx, DWORD PTR _pwszEventDDKName$[ebp]
	push	ecx
	call	?StringCbLengthW@@YGJPB_WIPAI@Z		; StringCbLengthW

; 210  : 
; 211  : 	*pwszEventSDKName = (PWCHAR)malloc( cbDDKName + sizeof( WCHAR ) - 11 * sizeof( WCHAR ) );

	mov	eax, DWORD PTR _cbDDKName$[ebp]
	sub	eax, 20					; 00000014H
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _pwszEventSDKName$[ebp]
	mov	DWORD PTR [ecx], eax

; 212  : 
; 213  : 	if( !(*pwszEventSDKName) )

	mov	eax, DWORD PTR _pwszEventSDKName$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@ConvertEve

; 214  : 	{
; 215  : 		SetLastError( ERROR_NOT_ENOUGH_MEMORY );

	mov	esi, esp
	push	8
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 216  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@ConvertEve
$LN1@ConvertEve:

; 217  : 	}
; 218  : 
; 219  : 	SecureZeroMemory(  *pwszEventSDKName, cbDDKName + sizeof( WCHAR ) - 11 * sizeof( WCHAR ) );

	mov	eax, DWORD PTR _cbDDKName$[ebp]
	sub	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _pwszEventSDKName$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_RtlSecureZeroMemory
	add	esp, 8

; 220  : 
; 221  : 	StringCbCopy( *pwszEventSDKName, 
; 222  : 		cbDDKName + sizeof( WCHAR ) - 11 * sizeof( WCHAR ), L"Global\\" );

	push	OFFSET ??_C@_1BA@LJDFMAL@?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AA?2?$AA?$AA@
	mov	eax, DWORD PTR _cbDDKName$[ebp]
	sub	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _pwszEventSDKName$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?StringCbCopyW@@YGJPA_WIPB_W@Z		; StringCbCopyW

; 223  : 
; 224  : 	StringCbCopy( *pwszEventSDKName + 7, 
; 225  : 		cbDDKName + sizeof( WCHAR ) - 18 * sizeof( WCHAR ), pwszEventDDKName + 18 );

	mov	eax, DWORD PTR _pwszEventDDKName$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _cbDDKName$[ebp]
	sub	ecx, 34					; 00000022H
	push	ecx
	mov	edx, DWORD PTR _pwszEventSDKName$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 14					; 0000000eH
	push	eax
	call	?StringCbCopyW@@YGJPA_WIPB_W@Z		; StringCbCopyW

; 226  : 
; 227  : 	return 1;

	mov	eax, 1
$LN2@ConvertEve:

; 228  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ConvertEve
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ConvertEve:
	DD	1
	DD	$LN5@ConvertEve
$LN5@ConvertEve:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@ConvertEve
$LN4@ConvertEve:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	68					; 00000044H
	DB	68					; 00000044H
	DB	75					; 0000004bH
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?ConvertEventName@@YAHPA_WPAPA_W@Z ENDP			; ConvertEventName
_TEXT	ENDS
PUBLIC	?DispatchReportFromServer@@YAKXZ		; DispatchReportFromServer
EXTRN	__imp__WaitForMultipleObjects@16:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ThreadForLogInFile@@YGKPAX@Z
_TEXT	SEGMENT
tv70 = -236						; size = 4
_IsTerminate$ = -36					; size = 4
_WaitStatus$ = -24					; size = 4
_handles_buf$ = -12					; size = 8
___formal$ = 8						; size = 4
?ThreadForLogInFile@@YGKPAX@Z PROC			; ThreadForLogInFile, COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 232  : 	HANDLE handles_buf[] = { hEventK, hEventThreadExit };

	mov	eax, DWORD PTR _hEventK
	mov	DWORD PTR _handles_buf$[ebp], eax
	mov	eax, DWORD PTR _hEventThreadExit
	mov	DWORD PTR _handles_buf$[ebp+4], eax

; 233  : 	DWORD WaitStatus;
; 234  : 	DWORD IsTerminate = 0;

	mov	DWORD PTR _IsTerminate$[ebp], 0
$LN7@ThreadForL:

; 235  : 
; 236  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@ThreadForL

; 237  : 	{
; 238  : 		WaitStatus = WaitForMultipleObjects( 2, handles_buf, FALSE, INFINITE );

	mov	esi, esp
	push	-1
	push	0
	lea	eax, DWORD PTR _handles_buf$[ebp]
	push	eax
	push	2
	call	DWORD PTR __imp__WaitForMultipleObjects@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _WaitStatus$[ebp], eax

; 239  : 
; 240  : 		switch( WaitStatus )

	mov	eax, DWORD PTR _WaitStatus$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 0
	je	SHORT $LN3@ThreadForL
	cmp	DWORD PTR tv70[ebp], 1
	je	SHORT $LN2@ThreadForL
	jmp	SHORT $LN4@ThreadForL
$LN3@ThreadForL:

; 241  : 		{
; 242  : 			case WAIT_OBJECT_0: // some data in buffer
; 243  : 			{ // sequence: 1. read data 2. set user event 3. translate scan-code to char 4. set register char
; 244  : 				// 5. check file size 6. write in file
; 245  : 				DispatchReportFromServer();

	call	?DispatchReportFromServer@@YAKXZ	; DispatchReportFromServer

; 246  : 				break;

	jmp	SHORT $LN4@ThreadForL
$LN2@ThreadForL:

; 247  : 			}
; 248  : 			case WAIT_OBJECT_0 + 1: // need terminate
; 249  : 			{
; 250  : 				IsTerminate = 1;

	mov	DWORD PTR _IsTerminate$[ebp], 1
$LN4@ThreadForL:

; 251  : 				break;
; 252  : 			}
; 253  : 		}
; 254  : 
; 255  : 		if( IsTerminate ) break;

	cmp	DWORD PTR _IsTerminate$[ebp], 0
	je	SHORT $LN1@ThreadForL
	jmp	SHORT $LN6@ThreadForL
$LN1@ThreadForL:

; 256  : 	}

	jmp	SHORT $LN7@ThreadForL
$LN6@ThreadForL:

; 257  : 
; 258  : 	return 1;

	mov	eax, 1

; 259  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@ThreadForL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN12@ThreadForL:
	DD	1
	DD	$LN11@ThreadForL
$LN11@ThreadForL:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN10@ThreadForL
$LN10@ThreadForL:
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?ThreadForLogInFile@@YGKPAX@Z ENDP			; ThreadForLogInFile
_TEXT	ENDS
PUBLIC	?TranslateScanCodeToCharAndWriteToLog@@YAXPAU_KEY@@@Z ; TranslateScanCodeToCharAndWriteToLog
EXTRN	__imp__SetEvent@4:PROC
EXTRN	_memmove:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DispatchReportFromServer@@YAKXZ
_TEXT	SEGMENT
_KeyData$ = -12						; size = 6
?DispatchReportFromServer@@YAKXZ PROC			; DispatchReportFromServer, COMDAT

; 262  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 263  : 	KEY KeyData;
; 264  : 
; 265  : 	memmove( &KeyData, pKey, sizeof( KEY ) );

	push	6
	mov	eax, DWORD PTR _pKey
	push	eax
	lea	ecx, DWORD PTR _KeyData$[ebp]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 266  : 
; 267  : 	SetEvent( hEventU );

	mov	esi, esp
	mov	eax, DWORD PTR _hEventU
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 268  : 
; 269  : 	/*if( KeyData.CapsLockOn == 0xFFFF && KeyData.ScanCode == 0xFFFF &&
; 270  : 		KeyData.ShiftPressed == 0xFFFF )
; 271  : 		return 0;*/
; 272  : 
; 273  : 	TranslateScanCodeToCharAndWriteToLog( &KeyData );

	lea	eax, DWORD PTR _KeyData$[ebp]
	push	eax
	call	?TranslateScanCodeToCharAndWriteToLog@@YAXPAU_KEY@@@Z ; TranslateScanCodeToCharAndWriteToLog
	add	esp, 4

; 274  : 
; 275  : 	return 1;

	mov	eax, 1

; 276  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@DispatchRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@DispatchRe:
	DD	1
	DD	$LN4@DispatchRe
$LN4@DispatchRe:
	DD	-12					; fffffff4H
	DD	6
	DD	$LN3@DispatchRe
$LN3@DispatchRe:
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?DispatchReportFromServer@@YAKXZ ENDP			; DispatchReportFromServer
_TEXT	ENDS
PUBLIC	?WriteInLogForTextMode@@YAXE@Z			; WriteInLogForTextMode
PUBLIC	__$ArrayPad$
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__ToAsciiEx@24:PROC
EXTRN	__imp__MapVirtualKeyExW@12:PROC
EXTRN	__imp__GetKeyboardState@4:PROC
EXTRN	__imp__GetKeyboardLayout@4:PROC
EXTRN	__imp__GetWindowThreadProcessId@8:PROC
EXTRN	__imp__GetForegroundWindow@0:PROC
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?TranslateScanCodeToCharAndWriteToLog@@YAXPAU_KEY@@@Z
_TEXT	SEGMENT
_vk$ = -360						; size = 4
_translate_status$ = -348				; size = 4
_ascii_char$ = -333					; size = 1
_Ch$ = -324						; size = 2
_State$ = -312						; size = 256
_layout$ = -48						; size = 4
_tid$ = -36						; size = 4
_num_write$ = -24					; size = 4
_pid$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pKey$ = 8						; size = 4
?TranslateScanCodeToCharAndWriteToLog@@YAXPAU_KEY@@@Z PROC ; TranslateScanCodeToCharAndWriteToLog, COMDAT

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-556]
	mov	ecx, 139				; 0000008bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 280  : 	DWORD pid;
; 281  : 	DWORD num_write;
; 282  : 	DWORD tid = 
; 283  : 		GetWindowThreadProcessId( GetForegroundWindow(), &pid );

	mov	esi, esp
	lea	eax, DWORD PTR _pid$[ebp]
	push	eax
	mov	edi, esp
	call	DWORD PTR __imp__GetForegroundWindow@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	DWORD PTR __imp__GetWindowThreadProcessId@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tid$[ebp], eax

; 284  : 
; 285  : 	HKL layout = GetKeyboardLayout( tid );

	mov	esi, esp
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	call	DWORD PTR __imp__GetKeyboardLayout@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _layout$[ebp], eax

; 286  : 	UCHAR State[256];
; 287  : 	WORD Ch;
; 288  : 	CHAR ascii_char;
; 289  : 	int translate_status;
; 290  : 
; 291  : 	GetKeyboardState( (PBYTE)&State );

	mov	esi, esp
	lea	eax, DWORD PTR _State$[ebp]
	push	eax
	call	DWORD PTR __imp__GetKeyboardState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 292  : 
; 293  : 	if( pKey->ShiftPressed )

	mov	eax, DWORD PTR _pKey$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN7@TranslateS

; 294  : 		State[VK_SHIFT] = 129;

	mov	BYTE PTR _State$[ebp+16], 129		; 00000081H

; 295  : 	else

	jmp	SHORT $LN6@TranslateS
$LN7@TranslateS:

; 296  : 		State[VK_SHIFT] = 0;

	mov	BYTE PTR _State$[ebp+16], 0
$LN6@TranslateS:

; 297  : 
; 298  : 	if( pKey->CapsLockOn )

	mov	eax, DWORD PTR _pKey$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	test	ecx, ecx
	je	SHORT $LN5@TranslateS

; 299  : 		State[VK_CAPITAL] = 129;

	mov	BYTE PTR _State$[ebp+20], 129		; 00000081H

; 300  : 	else

	jmp	SHORT $LN4@TranslateS
$LN5@TranslateS:

; 301  : 		State[VK_CAPITAL] = 0;

	mov	BYTE PTR _State$[ebp+20], 0
$LN4@TranslateS:

; 302  : 	
; 303  : 	UINT vk = MapVirtualKeyEx( pKey->ScanCode, 1, layout );

	mov	esi, esp
	mov	eax, DWORD PTR _layout$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pKey$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__MapVirtualKeyExW@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _vk$[ebp], eax

; 304  : 
; 305  : 
; 306  : 	//трансл€ци€ может не быть истинной из-за служебного символа
; 307  : 
; 308  : 
; 309  : 	translate_status = 
; 310  : 		ToAsciiEx( vk, pKey->ScanCode, State, &Ch, 0, layout );

	mov	esi, esp
	mov	eax, DWORD PTR _layout$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _Ch$[ebp]
	push	ecx
	lea	edx, DWORD PTR _State$[ebp]
	push	edx
	mov	eax, DWORD PTR _pKey$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _vk$[ebp]
	push	edx
	call	DWORD PTR __imp__ToAsciiEx@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _translate_status$[ebp], eax

; 311  : 
; 312  : 	if( translate_status > 0 )

	cmp	DWORD PTR _translate_status$[ebp], 0
	jle	SHORT $LN8@TranslateS

; 313  : 	{
; 314  : 		ascii_char = (char)Ch;

	mov	al, BYTE PTR _Ch$[ebp]
	mov	BYTE PTR _ascii_char$[ebp], al

; 315  : 		if( LogMode == Text )

	cmp	DWORD PTR _LogMode, 1
	jne	SHORT $LN2@TranslateS

; 316  : 			WriteInLogForTextMode( ascii_char );

	mov	al, BYTE PTR _ascii_char$[ebp]
	push	eax
	call	?WriteInLogForTextMode@@YAXE@Z		; WriteInLogForTextMode
	add	esp, 4

; 317  : 		else

	jmp	SHORT $LN8@TranslateS
$LN2@TranslateS:

; 318  : 			WriteFile( hLogFile, &ascii_char, 1, &num_write, NULL );

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _num_write$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _ascii_char$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLogFile
	push	edx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@TranslateS:

; 319  : 	}
; 320  : 	//проверить возвращаемый статус
; 321  : 	
; 322  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@TranslateS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 556				; 0000022cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@TranslateS:
	DD	5
	DD	$LN15@TranslateS
$LN15@TranslateS:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN10@TranslateS
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN11@TranslateS
	DD	-312					; fffffec8H
	DD	256					; 00000100H
	DD	$LN12@TranslateS
	DD	-324					; fffffebcH
	DD	2
	DD	$LN13@TranslateS
	DD	-333					; fffffeb3H
	DD	1
	DD	$LN14@TranslateS
$LN14@TranslateS:
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	0
$LN13@TranslateS:
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	0
$LN12@TranslateS:
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$LN11@TranslateS:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$LN10@TranslateS:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
?TranslateScanCodeToCharAndWriteToLog@@YAXPAU_KEY@@@Z ENDP ; TranslateScanCodeToCharAndWriteToLog
_TEXT	ENDS
PUBLIC	?StartLog@@YGHXZ				; StartLog
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?StartLog@@YGHXZ
_TEXT	SEGMENT
_cbRet$ = -8						; size = 4
?StartLog@@YGHXZ PROC					; StartLog, COMDAT

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 326  : 	ULONG cbRet;
; 327  : 
; 328  : 	if( ServerStatus != Initialize )

	cmp	DWORD PTR _ServerStatus, 1
	je	SHORT $LN2@StartLog

; 329  : 	{
; 330  : 		SetLastError( ERROR_INVALID_FUNCTION );

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 331  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@StartLog
$LN2@StartLog:

; 332  : 	}
; 333  : 
; 334  : 	if( !DeviceIoControl( hKbdHookDev, IOCTL_KBD_HOOK_START, NULL, 0, 
; 335  : 		NULL, 0, &cbRet, NULL ) )

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _cbRet$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	2254428					; 0022665cH
	mov	ecx, DWORD PTR _hKbdHookDev
	push	ecx
	call	DWORD PTR __imp__DeviceIoControl@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@StartLog

; 336  : 	{
; 337  : 		SetLastError( ERROR_INTERNAL_ERROR );

	mov	esi, esp
	push	1359					; 0000054fH
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 338  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@StartLog
$LN1@StartLog:

; 339  : 	}
; 340  : 
; 341  : 	SetServerStatus( LogInProgress );

	push	2
	call	?SetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z ; SetServerStatus
	add	esp, 4

; 342  : 	SetLastError( ERROR_SUCCESS );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 343  : 
; 344  : 	return TRUE;

	mov	eax, 1
$LN3@StartLog:

; 345  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@StartLog
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@StartLog:
	DD	1
	DD	$LN6@StartLog
$LN6@StartLog:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN5@StartLog
$LN5@StartLog:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?StartLog@@YGHXZ ENDP					; StartLog
_TEXT	ENDS
PUBLIC	?UnSetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z	; UnSetServerStatus
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?StopLog@@YGHXZ
_TEXT	SEGMENT
_cbRet$ = -8						; size = 4
?StopLog@@YGHXZ PROC					; StopLog, COMDAT

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 349  : 	ULONG cbRet;
; 350  : 
; 351  : 	if( ServerStatus != LogInProgress )

	cmp	DWORD PTR _ServerStatus, 2
	je	SHORT $LN2@StopLog

; 352  : 	{
; 353  : 		SetLastError( ERROR_INVALID_FUNCTION );

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 354  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@StopLog
$LN2@StopLog:

; 355  : 	}
; 356  : 	
; 357  : 	if( !DeviceIoControl( hKbdHookDev, IOCTL_KBD_HOOK_STOP, NULL, 0, 
; 358  : 		NULL, 0, &cbRet, NULL ) )

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _cbRet$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	2254424					; 00226658H
	mov	ecx, DWORD PTR _hKbdHookDev
	push	ecx
	call	DWORD PTR __imp__DeviceIoControl@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@StopLog

; 359  : 	{
; 360  : 		SetLastError( ERROR_INTERNAL_ERROR );

	mov	esi, esp
	push	1359					; 0000054fH
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 361  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@StopLog
$LN1@StopLog:

; 362  : 	}
; 363  : 
; 364  : 	UnSetServerStatus( LogInProgress );

	push	2
	call	?UnSetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z ; UnSetServerStatus
	add	esp, 4

; 365  : 	SetLastError( ERROR_SUCCESS );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 366  : 
; 367  : 	return TRUE;

	mov	eax, 1
$LN3@StopLog:

; 368  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@StopLog
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@StopLog:
	DD	1
	DD	$LN6@StopLog
$LN6@StopLog:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN5@StopLog
$LN5@StopLog:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?StopLog@@YGHXZ ENDP					; StopLog
_TEXT	ENDS
EXTRN	__imp__WaitForSingleObject@8:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?UnInitKbdHook@@YGHXZ
_TEXT	SEGMENT
_cbRet$ = -8						; size = 4
?UnInitKbdHook@@YGHXZ PROC				; UnInitKbdHook, COMDAT

; 371  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 372  : 	ULONG cbRet;
; 373  : 
; 374  : 	if( ServerStatus != Initialize )

	cmp	DWORD PTR _ServerStatus, 1
	je	SHORT $LN2@UnInitKbdH

; 375  : 	{
; 376  : 		SetLastError( ERROR_INVALID_FUNCTION );

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 377  : 		return FALSE;

	xor	eax, eax
	jmp	$LN3@UnInitKbdH
$LN2@UnInitKbdH:

; 378  : 	}
; 379  : 
; 380  : 	if( !DeviceIoControl( hKbdHookDev, IOCTL_KBD_HOOK_UNINIT, NULL, 0,
; 381  : 		NULL, 0, &cbRet, NULL ) )

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _cbRet$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	2254432					; 00226660H
	mov	ecx, DWORD PTR _hKbdHookDev
	push	ecx
	call	DWORD PTR __imp__DeviceIoControl@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@UnInitKbdH

; 382  : 	{
; 383  : 		SetLastError( ERROR_INTERNAL_ERROR );

	mov	esi, esp
	push	1359					; 0000054fH
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 384  : 		return FALSE;

	xor	eax, eax
	jmp	$LN3@UnInitKbdH
$LN1@UnInitKbdH:

; 385  : 	}
; 386  : 
; 387  : 	SetEvent( hEventThreadExit );

	mov	esi, esp
	mov	eax, DWORD PTR _hEventThreadExit
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 388  : 	WaitForSingleObject( hThread, INFINITE );

	mov	esi, esp
	push	-1
	mov	eax, DWORD PTR _hThread
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 389  : 
; 390  : 	UnSetServerStatus( Initialize );

	push	1
	call	?UnSetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z ; UnSetServerStatus
	add	esp, 4

; 391  : 	SetLastError( ERROR_SUCCESS );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 392  : 
; 393  : 	free( pwszEventUName );

	mov	eax, DWORD PTR _pwszEventUName
	push	eax
	call	_free
	add	esp, 4

; 394  : 	free( pwszEventKName );

	mov	eax, DWORD PTR _pwszEventKName
	push	eax
	call	_free
	add	esp, 4

; 395  : 	free( pwszLogFileName );

	mov	eax, DWORD PTR _pwszLogFileName
	push	eax
	call	_free
	add	esp, 4

; 396  : 	VirtualFree( pKey, 4096, MEM_RELEASE );

	mov	esi, esp
	push	32768					; 00008000H
	push	4096					; 00001000H
	mov	eax, DWORD PTR _pKey
	push	eax
	call	DWORD PTR __imp__VirtualFree@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 397  : 	CloseHandle( hLogFile );

	mov	esi, esp
	mov	eax, DWORD PTR _hLogFile
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 398  : 	CloseHandle( hEventK );

	mov	esi, esp
	mov	eax, DWORD PTR _hEventK
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 399  : 	CloseHandle( hEventU );

	mov	esi, esp
	mov	eax, DWORD PTR _hEventU
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 400  : 	CloseHandle( hKbdHookDev );

	mov	esi, esp
	mov	eax, DWORD PTR _hKbdHookDev
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 401  : 
; 402  : 	return TRUE;

	mov	eax, 1
$LN3@UnInitKbdH:

; 403  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@UnInitKbdH
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@UnInitKbdH:
	DD	1
	DD	$LN6@UnInitKbdH
$LN6@UnInitKbdH:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN5@UnInitKbdH
$LN5@UnInitKbdH:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?UnInitKbdHook@@YGHXZ ENDP				; UnInitKbdHook
_TEXT	ENDS
EXTRN	__imp__InterlockedIncrement@4:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z
_TEXT	SEGMENT
_PrevState$ = -8					; size = 4
_RequiredState$ = 8					; size = 4
?SetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z PROC	; SetServerStatus, COMDAT

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 407  : 	STATUS_OF_SERVER PrevState = (STATUS_OF_SERVER)((DWORD)RequiredState - 1);

	mov	eax, DWORD PTR _RequiredState$[ebp]
	sub	eax, 1
	mov	DWORD PTR _PrevState$[ebp], eax

; 408  : 
; 409  : 	if( RequiredState == UnInitialize ) return FALSE;

	cmp	DWORD PTR _RequiredState$[ebp], 0
	jne	SHORT $LN3@SetServerS
	xor	eax, eax
	jmp	SHORT $LN4@SetServerS
$LN3@SetServerS:

; 410  : 
; 411  : 	if( ServerStatus == PrevState )

	mov	eax, DWORD PTR _ServerStatus
	cmp	eax, DWORD PTR _PrevState$[ebp]
	jne	SHORT $LN2@SetServerS

; 412  : 		InterlockedIncrement( (LONG*)&ServerStatus );

	mov	esi, esp
	push	OFFSET _ServerStatus
	call	DWORD PTR __imp__InterlockedIncrement@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 413  : 	else

	jmp	SHORT $LN1@SetServerS
$LN2@SetServerS:

; 414  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN4@SetServerS
$LN1@SetServerS:

; 415  : 
; 416  : 	return TRUE;

	mov	eax, 1
$LN4@SetServerS:

; 417  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z ENDP	; SetServerStatus
_TEXT	ENDS
EXTRN	__imp__InterlockedDecrement@4:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?UnSetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z
_TEXT	SEGMENT
_StateForUnset$ = 8					; size = 4
?UnSetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z PROC	; UnSetServerStatus, COMDAT

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 421  : 	if( StateForUnset == UnInitialize ) return FALSE;

	cmp	DWORD PTR _StateForUnset$[ebp], 0
	jne	SHORT $LN3@UnSetServe
	xor	eax, eax
	jmp	SHORT $LN4@UnSetServe
$LN3@UnSetServe:

; 422  : 
; 423  : 	if( ServerStatus == StateForUnset )

	mov	eax, DWORD PTR _ServerStatus
	cmp	eax, DWORD PTR _StateForUnset$[ebp]
	jne	SHORT $LN2@UnSetServe

; 424  : 		InterlockedDecrement( (LONG*)&ServerStatus );

	mov	esi, esp
	push	OFFSET _ServerStatus
	call	DWORD PTR __imp__InterlockedDecrement@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 425  : 	else

	jmp	SHORT $LN1@UnSetServe
$LN2@UnSetServe:

; 426  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN4@UnSetServe
$LN1@UnSetServe:

; 427  : 
; 428  : 	return TRUE;

	mov	eax, 1
$LN4@UnSetServe:

; 429  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?UnSetServerStatus@@YAHW4STATUS_OF_SERVER@@@Z ENDP	; UnSetServerStatus
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?WriteInLogForTextMode@@YAXE@Z
_TEXT	SEGMENT
_num_write$ = -20					; size = 4
_enter$ = -8						; size = 2
_ch$ = 8						; size = 1
?WriteInLogForTextMode@@YAXE@Z PROC			; WriteInLogForTextMode, COMDAT

; 432  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 433  : 	char enter[2] = { '\xD','\xA' };

	mov	BYTE PTR _enter$[ebp], 13		; 0000000dH
	mov	BYTE PTR _enter$[ebp+1], 10		; 0000000aH

; 434  : 	ULONG num_write;
; 435  : 
; 436  : 	if( ch == '\xD' )

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN7@WriteInLog

; 437  : 		WriteFile( hLogFile, &enter, 2, &num_write, NULL );

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _num_write$[ebp]
	push	eax
	push	2
	lea	ecx, DWORD PTR _enter$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLogFile
	push	edx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN8@WriteInLog
$LN7@WriteInLog:

; 438  : 	else if( ch == 'x9' )

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 30777				; 00007839H
	jne	SHORT $LN5@WriteInLog

; 439  : 		WriteFile( hLogFile, &ch, 1, &num_write, NULL );

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _num_write$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLogFile
	push	edx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN8@WriteInLog
$LN5@WriteInLog:

; 440  : 	else if( ch >= '\x20' && ch < '\x7F'  )

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN3@WriteInLog
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 127				; 0000007fH
	jge	SHORT $LN3@WriteInLog

; 441  : 		WriteFile( hLogFile, &ch, 1, &num_write, NULL );

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _num_write$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLogFile
	push	edx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN8@WriteInLog
$LN3@WriteInLog:

; 442  : 	else if( ch > '\x7F' )

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 127				; 0000007fH
	jle	SHORT $LN8@WriteInLog

; 443  : 		WriteFile( hLogFile, &ch, 1, &num_write, NULL );

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _num_write$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLogFile
	push	edx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@WriteInLog:

; 444  : 	
; 445  : 	return;
; 446  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@WriteInLog
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@WriteInLog:
	DD	2
	DD	$LN12@WriteInLog
$LN12@WriteInLog:
	DD	-8					; fffffff8H
	DD	2
	DD	$LN10@WriteInLog
	DD	-20					; ffffffecH
	DD	4
	DD	$LN11@WriteInLog
$LN11@WriteInLog:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$LN10@WriteInLog:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?WriteInLogForTextMode@@YAXE@Z ENDP			; WriteInLogForTextMode
_TEXT	ENDS
END
